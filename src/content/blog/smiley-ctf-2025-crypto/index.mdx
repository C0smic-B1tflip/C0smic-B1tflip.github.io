---
title: 'smileyCTF 2025 crypto writeups'
description: 'We placed 7th overall in smileyCTF, and we managed to solve 4 out of 7 crypto challenges. Here are the writeups for the 4 that we solved.'
date: 2025-06-16
image: './psyduck.png'
authors: ['elecat']
---

# saas
> Every ctf has to have a chall called 'saas'. Its just tradition.
### Source
```py
#!/usr/local/bin/python
from Crypto.Util.number import getPrime as gP
from random import choice, randint
p, q = gP(512), gP(512)
while p % 4 != 3:
    p = gP(512)

while q % 4 != 3:
    q = gP(512)

n = p * q
e = 0x10001

f = lambda x: ((choice([-1,1]) * pow(x, (p + 1) // 4, p)) * pow(q, -1, p) * q + (choice([-1,1]) * pow(x, (q + 1) // 4, q)) % q * pow(p, -1, q) * p) % n

while True:
    try:
        l = int(input(">>> ")) % n
        print(f(l))
    except:
        break

m = randint(0, n - 1)
print(f"{m = }")
s = int(input(">>> ")) % n
if pow(s,e,n) == m:
    print(open("flag.txt", "r").read())
else:
    print("Wrong signature!")
    exit(1)
```
The hint function `f` will let us factor n, which will allow us to easily forge RSA signatures.
```py
f = lambda x: (
    (choice([-1,1]) * pow(x, (p + 1) // 4, p)) * pow(q, -1, p) * q +
    (choice([-1,1]) * pow(x, (q + 1) // 4, q)) % q * pow(p, -1, q) * p
) % n
```
Other inputs can be used as well, but the easiest way is to just enter `1` several times since it simplifies the `pow(x, (p + 1) // 4, p)` expressions.
If `x = 1`, `f` simplifies to:

$$
(\pm 1) * (q^{-1} \bmod p) * q + (\pm 1 \bmod q) * (p^{-1} \bmod q) * p \pmod n
$$

Let's consider the 4 cases based on the `choice([-1, 1])` functions. If they're both 1, then:

$$
\begin{align*}
(q^{-1} \bmod p) * q + (p^{-1} \bmod q) * p &= 1 \pmod p \\
(q^{-1} \bmod p) * q + (p^{-1} \bmod q) * p &= 1 \pmod q \\
&= 1 \pmod n
\end{align*}
$$

Well, that's not very helpful. Let's see what happens if they're both -1.
$$
\begin{align*}
-(q^{-1} \bmod p) * q + (-1 \bmod q) * (p^{-1} \bmod q) * p &= -1 \pmod p \\
-(q^{-1} \bmod p) * q + (-1 \bmod q) * (p^{-1} \bmod q) * p &= -1 \pmod q \\
= -1 &= n - 1 \pmod n
\end{align*}
$$
Since we weren't already given $n$, this helps, but we still have to factor it. Let's try -1 and then 1.

$$
\begin{align*}
-(q^{-1} \bmod p) * q + (p^{-1} \bmod q) * p &= -1 \pmod p \\
-(q^{-1} \bmod p) * q + (p^{-1} \bmod q) * p &= 1 \pmod q \\
&= x \pmod n
\end{align*}
$$
(Similarly, we can verify that 1 and then -1 gives $1 \bmod p$ and $-1 \bmod q$).If $x = -1 \bmod p$ then $\gcd(x+1, n) = p$. Now that we know $n$ and $p$, we can forge $s = m^d$ as usual. Connect to the server:
```
>>> 1
22584873973170387532631975715183528422437016681010618464581741882284345475758086005221539371683857475009200576502143088424522374562879237368635174156835283415890738492843061847279270354725129748353239745320933642792426188606836171676085221631281998525476933677154286648781607693710919190128678155081909268088
>>> 1
57515301216124622590566072376518371083992119569511667096809751291595343959859178121431978621164550685800822333376445699489444284601257225874255447364949171605200949316779305883182575252401100832245566541186202985973093581871838640842808631676969088876776493499364932189494081880465288341782241504351251269985
>>> 1
22584873973170387532631975715183528422437016681010618464581741882284345475758086005221539371683857475009200576502143088424522374562879237368635174156835283415890738492843061847279270354725129748353239745320933642792426188606836171676085221631281998525476933677154286648781607693710919190128678155081909268088
>>> 1
80100175189295010123198048091701899506429136250522285561391493173879689435617264126653517992848408160810022909878588787913966659164136463242890621521784455021091687809622367730461845607126230580598806286507136628765519770478674812518893853308251087402253427176519218838275689574176207531910919659433160538072
>>> 
m = 53132934961200371180676162016341077654053922574943513666756222188084025661854865495927497737291401394349343056615078365876002760589653075983366529467611919986059455834413643048169959689387574237792950919554760828723038198835312635797931913782213768728290856702322316506344912730319204467752773777243157325701
>>> 20099041860533093891537787115551939590459747423543968198303933596565566658678985923271987920254172557043540713252140285247197236483427948785565652040279580299735124260366230344421118005522477491963228467520988599509254330856682864301571056119290774894214445107716375324246758240798939405391977606674070669038
.;,;.{squares_as_a_service_est_like_the_dawn_of_time}
```

(Since `801...` is the largest, we know it must be $n - 1$.)
### Final script:
```py
from Crypto.Util.number import *
from math import gcd

out1 = 80100175189295010123198048091701899506429136250522285561391493173879689435617264126653517992848408160810022909878588787913966659164136463242890621521784455021091687809622367730461845607126230580598806286507136628765519770478674812518893853308251087402253427176519218838275689574176207531910919659433160538072
out2 = 57515301216124622590566072376518371083992119569511667096809751291595343959859178121431978621164550685800822333376445699489444284601257225874255447364949171605200949316779305883182575252401100832245566541186202985973093581871838640842808631676969088876776493499364932189494081880465288341782241504351251269985
m = 53132934961200371180676162016341077654053922574943513666756222188084025661854865495927497737291401394349343056615078365876002760589653075983366529467611919986059455834413643048169959689387574237792950919554760828723038198835312635797931913782213768728290856702322316506344912730319204467752773777243157325701

n = out1 + 1
p = gcd(n, out2 + 1)
q = n//p
e = 0x10001
phi = (p - 1) * (q - 1)
d = pow(e, -1, phi)
s = pow(m, d, n)

print(s)
```
flag: `.;,;.{squares_as_a_service_est_like_the_dawn_of_time}`
# never enough
TODO
# LCGs are SBGs
TODO (or is wjat doing this or something)
# sums
TODO